<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CustomAssets: [Custom Assets](http://www.askowl.net/unity-custom-assets)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Askowl-100x100.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CustomAssets
   </div>
   <div id="projectbrief">Askowl Custom Assets</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('autotoc_md0.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">[Custom Assets](<a href="http://www.askowl.net/unity-custom-assets">http://www.askowl.net/unity-custom-assets</a>) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ul>
<li>Table of Contents {:toc}</li>
</ul>
<blockquote class="doxtable">
<p>The Doxygen pages are <a href="https://paulmarrington.github.io/Unity-Documentation/CustomAssets/Doxygen/html/annotated.html">here</a> </p>
</blockquote>
<p>Custom assets are all about decoupling. They are project resources that contain data and code wrapped in a Unity ScriptableObject. They provide emitters to signal change and persistence between sessions. Read the list of benefits <a href="#benefits">here</a> and watch the video introduction <a href="https://www.youtube.com/watch?v=">here</a>.</p>
<p>I have chosen to use this executive summary to provide examples of how you can use custom assets.</p>
<h3>Decoupling Components</h3>
<p>After you create a custom asset in the project, any reference in components is to the same object. Our example is the ubiquitous player health - a value between zero and one that needs to be accessed by components to:</p><ul>
<li>display a health bar on the screen</li>
<li>show health percentages on a status page</li>
<li>trigger death animation on reaching zero</li>
<li>be reduced by damage (hit, poison, fall)</li>
<li>be increased by time, potions, med-kits.</li>
<li>be reviewed by other actions (such as no jumping on low health)</li>
<li>In this example a CustomAsset.Float project resource does the job while markedly reducing the amount of code and support compared to a singleton.</li>
</ul>
<p>See how easy it is to create <a href="#health-bar">here</a> e in <a href="https://www.youtube.com/watch?v=">this</a> short video including testing framework. Use the same techniques for stamina, mana, progress and the many other measures used in games. Then branch out to more uses.</p>
<h3>Game Managers</h3>
<p>The traditional approach of using a MonoBehaviour as a manager creates a system that is difficult to test in isolation. <a href="https://www.youtube.com/watch?v=">Here</a> we have a video on creating the framework for a health manager using custom assets. Go <a href="#health-manager">here</a> if you prefer to read.</p>
<p>Refactoring existing code into custom asset managers can be done in very little time while providing benefits in stability, flexibility and testing. <a href="#refactoring-to-use-custom-assets">Here</a> is a non-trivial example from existing code.</p>
<h3>Persistent Storage</h3>
<p>Every mutable custom asset includes a checkbox in the inspector for persistent storage. Data saves when changed and restored on program restart.</p>
<blockquote class="doxtable">
<p>Read the code in the Examples Folder and run the Example scene </p>
</blockquote>
<ul>
<li>A Health System Example<ol type="1">
<li><a href="https://youtu.be/7P6fc-AQfnk">The Health Bar</a></li>
<li><a href="https://youtu.be/pgzjMbyY7tc">The Health Manager</a></li>
</ol>
</li>
<li><a href="https://youtu.be/juJ-R53hlaE">Converting a Game Manager to Custom Assets</a></li>
</ul>
<ul>
<li><em><b>Manager</b></em>: Basic custom asset. Loaded in Managers game object or with Manager.Load for testing</li>
</ul>
<h3>Mutable Custom Assets</h3>
<p>Entries can be changed and listeners can register to react to the change.</p><ul>
<li><em><b>AudioClips</b></em> - AudioClipSet where list of clips can be modified</li>
<li><em><b>Boolean</b></em></li>
<li><em><b>ChangeOverTime</b></em> - Given a Float custom asset, change it's slowly</li>
<li><em><b>Field</b></em> - Static helper class for setting fields in a compound custom assets</li>
<li><em><b>Float</b></em></li>
<li><em><b>GameObject</b></em> - Use with connector to access a game object from a custom asset</li>
<li><em><b>Integer</b></em></li>
<li><em><b>OfType</b></em> - Base mutable providing emitter and persistence activities</li>
<li><em><b>String</b></em></li>
<li><em><b>StringSet</b></em> - List of strings with picker</li>
<li><em><b>Trigger</b></em> - Fired on command instead of on change</li>
</ul>
<h3>Constant Custom Assets</h3>
<ul>
<li><em><b>AudioClips</b></em> - Pick from AudioClipSet</li>
<li><em><b>AudioClipSet</b></em> - Picker for clip, volume, pitch and distance</li>
<li><em><b>Base</b></em> - Base class for all custom assets</li>
<li><em><b>Boolean</b></em></li>
<li><em><b>Enumeration</b></em> - Subclass to define set</li>
<li><em><b>Float</b></em></li>
<li><em><b>Integer</b></em></li>
<li><em><b>OfType</b></em> - Base class for all constant custom assets</li>
<li><em><b>Quotes</b></em> - Pick a quote from a QuoteSet</li>
<li><em><b>QuoteSet</b></em> - Quotes container loaded from text assets</li>
<li><em><b>String</b></em></li>
<li><em><b>StringSet</b></em> - Set of strings when Enumeration is too heavy duty</li>
</ul>
<h3>Connectors</h3>
<ul>
<li><em><b>Animator</b></em> - Given the parameter name, trigger or set bool, int or float animation control.</li>
<li><em><b>GameObject</b></em> - give access to a game object from a custom asset</li>
<li><em><b>RectTransform</b></em> - access/update position and anchors</li>
<li><em><b>Transform</b></em> - access/update size and scale</li>
</ul>
<h3>Drivers</h3>
<ul>
<li><em><b>Boolean</b></em> - for boolean unity events</li>
<li><em><b>Driver</b></em> - Register and deregister the listener with the channel</li>
<li><em><b>Integer</b></em> - for integer unity events</li>
<li><em><b>NamedBoolean</b></em> - driver for named events used in the animator</li>
<li><em><b>NamedFloat</b></em> - driver for named events used in the animator</li>
<li><em><b>NamedInteger</b></em> - driver for named events used in the animator</li>
<li><em><b>NamedString</b></em> - driver for named events used in the animator</li>
<li><em><b>NamedTrigger</b></em> - driver for named events used in the animator</li>
<li><em><b>String</b></em> - for string unity events</li>
<li><em><b>Trigger</b></em> - for action trigger unity events</li>
</ul>
<p>Unity provides a base class called <a href="https://docs.unity3d.com/ScriptReference/ScriptableObject.html">ScriptableObject</a>. Derive from them to create objects or assets that don't need to be attached to game objects.</p>
<p>In short, a <code>ScriptableObject</code> is a class that contains serialisable data and functionality. Each instance of a class that derives from <code>ScriptableObject</code> has representation on disk as an asset. Each asset is a source for data and actions not coupled to a scene. The decoupling makes for functionality that is easy to test. It also provides modules to be shared across and between projects.</p>
<p>Custom assets are Unity scriptable objects on steroids. They provide the glue that allows you to piece together a better game.</p>
<ol type="1">
<li>Better than singletons<ol type="a">
<li>Share information across scenes, game objects and components; and</li>
<li>Seed it as a resource in the project; and</li>
<li>Have it made read-only, read/write and even persistent; and</li>
<li>Drive components directly without additional code; and</li>
<li>Add a description to each custom asset to clarify usage; and</li>
</ol>
<ol type="a">
<li>Attach to existing components to provide dynamic action without code<ol type="i">
<li>Start and stop animations with a trigger, boolean, integer or float custom asset; or</li>
<li>Control canvas groups, image fill or text field content with float and string custom assets</li>
</ol>
</li>
</ol>
</li>
<li>Packaged with many useful standard custom assets<ol type="a">
<li><em><b>Boolean</b></em> - where components can react to a change of state</li>
<li><em><b>Integer</b></em> - that can be changed by code or visual slider</li>
<li><em><b>Float</b></em> - components can react and/or display results on value change</li>
<li><em><b>String</b></em> - for display or detailed action control</li>
<li><em><b>StringSet</b></em> - provides a more powerful and flexible alternative to enums</li>
<li><em><b>Trigger</b></em> - an emitter where components can attach as needed without additional code</li>
<li><em><b>Polling</b></em> - to provide custom asset triggers for external data changes</li>
<li><em><b>AudioClips</b></em> - allowing random selection from a set of audio clips with variations in volume, pitch and distance to provide a better audio experience for your players</li>
<li><em><b>Quotes</b></em> - Load and retrieve text from within the component or other text resource files either randomly or in sequence. Good for quotes, jokes, game hints or news feeds.</li>
</ol>
</li>
<li>Create your custom assets with any serialisable data and optional supporting scripts</li>
<li>Every custom asset has a dictionary of members to save more than one copy of data - accessed by name.</li>
</ol>
<h3>Custom Assets - the new Singleton</h3>
<p>Static variables are not evil, just inflexible. Singleton MonoBehaviour instances are not corrupt either. However, both encourage tight coupling between interested parties.</p>
<p>So now for a bit of mild blasphemy. Assets created from scriptable objects, and hence custom assets are Unity supported <em>singletons</em>. Create <code>[SerializeField]</code> fields and drag an asset of the correct type onto them in the editor. All reference to the same in-memory instance.</p>
<p>Using custom assets over traditional singletons provide some benefits:</p>
<ul>
<li>Code is less coupled - or is that more decoupled?</li>
<li>Custom assets can be tested in isolation.</li>
<li>Alternative custom assets can be injected into objects that are expecting them. An inventory may depend on location or whether the player is in training mode.</li>
<li>It is less error prone to pass custom assets between scenes and projects.</li>
<li>Functionality can be more generalised for direct reuse from within the editor without writing as much scaffolding code. A <code>Float</code> custom asset, for example, can have components that hook into display objects. Sliders and scroll-bars can also update it without additional code by adding it to the <em>On Value Changed</em> field.</li>
<li>A custom asset as a singleton to hold game data has one massive failing. There is one copy only. If you want to store player health for an unknown number of players, how do we save it? For this, custom assets have the concept of members. Each named entry holds a reference to the custom asset storage that can be accessed by member name.</li>
</ul>
<h3>Custom Assets as Game Managers</h3>
<p>Managers are a favourite Unity pattern. As well as a system-wide master manager, many games have them for player, enemies, sound and more. They have some standard features:</p>
<ul>
<li>They are accessed by a static <code>Instance</code> variable.</li>
<li>They are a MonoBehaviour that sets <code>Instance</code> in <code>Awake()</code>.</li>
<li>They call <code>DontDestroyOnLoad(gameObject)</code> if they are to be common across scenes.</li>
<li>There is often one manager to rule them all.</li>
</ul>
<p>It is not uncommon to see code like:</p>
<div class="fragment"><div class="line">{c#}</div><div class="line">health = GameManager.Instance.PlayerManager.MaxHealth;</div></div><!-- fragment --><p>Try testing that component in isolation.</p>
<p>By contrast, a custom asset approach would be more like:</p>
<div class="fragment"><div class="line">{c#}</div><div class="line">[SerializeField] maxHealth;</div><div class="line">...</div><div class="line">health = maxHealth;</div></div><!-- fragment --><p>Manager custom assets are the most useful when decoupled. They deal with data custom assets by making changes and responding to events. This manager can be tested in isolation without loading the complete game. Test in concert with the HealthManager and the HitManager for more complex scenarios.</p>
<div class="fragment"><div class="line">[CreateAssetMenu(menuName = &quot;Managers/Armor&quot;), Serializable]</div><div class="line">public class ArmorManager : Manager {</div><div class="line">  [SerializeField] private Float armorStrength = default;</div><div class="line">  [SerializeField] private Float hitAmount = default;</div><div class="line">  [SerializeField] private Float health = default;</div><div class="line">  [SerializeField] private Float armorDegradation = default;</div><div class="line"></div><div class="line">  protected override void Initialise() =&gt; hitAmount.Emitter.Subscribe(OnHit);</div><div class="line"></div><div class="line">  private void OnHit() {</div><div class="line">    // the stronger the armor the less a hit will do damage</div><div class="line">    var adjustedHit = hitAmount * (1.0f - armorStrength);</div><div class="line">    health.value -= adjustedHit;</div><div class="line">    // But eac hit damages the armor a little</div><div class="line">    armorStrength -= hitAmount * armorDegradation;</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --> <h4>Manager Loading</h4>
<p>Player managers should be logic. Data have their custom assets. Since managers only react to events, they need to be explicitly loaded. In the Unity editor select the menu <em><b>GameObject // Create Managers</b></em>. Drag the managers into the list in the newly created MonoBehaviour.</p>
<div class="image">
<img src="Managers.png" alt="Manager Custom Asset Container"/>
</div>
<p>For testing, we don't need a scene — another benefit of decoupling. <code>Manager</code> provides a <code>Load</code> method for independent testing. The asset can be found by name with or without a path. Only as much of the path as needed for uniqueness needs be given.</p>
<div class="fragment"><div class="line">public class HealthManagerTest : PlayModeTests {</div><div class="line">  [UnityTest, Timeout(100000)] public IEnumerator HealthManager() {</div><div class="line">    //- Our health component will take 1,000 seconds to go from zero to full. Let&#39;s speed things up by 10x</div><div class="line">    Time.timeScale = 10;</div><div class="line">    try {</div><div class="line">      //- We don&#39;t need a specific scene, just load the custom assets</div><div class="line">      Manager.Load&lt;HealthManagerTranscript&gt;(&quot;HealthManager.asset&quot;);</div><div class="line">      var health = Manager.Load&lt;Float&gt;(&quot;Health.asset&quot;);</div><div class="line">      health.Set(0);</div><div class="line">      //- Timeout attribute will cause a test failure after 10 seconds</div><div class="line">      while (true) {</div><div class="line">        //- This causes a 1/10th of a second delay due to the modified scale</div><div class="line">        yield return new WaitForSeconds(1.0f);</div><div class="line">        //- Leaving once the test passes is a successful result. This should take 1 second at the current time scale.</div><div class="line">        if (health &gt;= 0.01f) yield break;</div><div class="line">      }</div><div class="line">    } finally {</div><div class="line">      Time.timeScale = 1;</div><div class="line">    }</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><h3>Custom Assets as Configuration</h3>
<p>The most common use for scriptable objects is to ignore the scriptable part and use them as configuration containers. A Custom Asset is a file within the project. This file contains a reference to the script and serialised copies of all the data as added in the Unity editor.</p>
<p>You can safeguard the serialisable data by making it a private <code>[SerializeField]</code> and using accessors to allow reading. Alternatively, you can use them as seed data and change them during program execution.</p>
<div class="fragment"><div class="line">{c#}</div><div class="line">class MyData : CustomAsset {</div><div class="line">[SerializeField] private int maxHealth;</div><div class="line">[SerializeField] private float timeOfDay;</div><div class="line"></div><div class="line">// maxHealth cannot be changed outside this class</div><div class="line">public int MaxHealth { get { return maxHealth; } };</div><div class="line">// timeOfDay can be updated</div><div class="line">public float TimeOfDay { get { return timeOfDay; } set { timeOfDay = value; } };</div></div><!-- fragment --><p> Later I will introduce better and more granular ways to handle data.</p>
<h3>Read-only Custom Assets</h3>
<p>The custom asset inspector allows a designer to mark the asset read-only For serialisable classes as values, protection of internal data is still code bases. Make the fields private and serialisable so that the editor can change them. Then use accessors without <code>set</code> to only allow for reading. If you can't trust the code accessing data in a complex object graph, either clone the custom asset or lock down access at all levels.</p>
<div class="fragment"><div class="line">{c#}</div><div class="line">var clone = Object.Instantiate(myCustomAsset).Value;</div></div><!-- fragment --><p>Cloning is much more expensive at runtime than baking in protection during the compile phase.</p>
<h3>Custom Assets and Persistence</h3>
<p>Custom Assets adds optional persistence to scriptable objects. Persistent assets must be read/write and have the <code>persistent</code> field set in the Unity Editor.</p>
<p>Each persistent object is serialised to JSON and written as a <code>PlayerPref</code> entity. For this reason, the total storage is about one megabyte. For more massive storage needs, use a database.</p>
<p>The key is made up of the name of the asset and the class name, making it unique to the application.</p>
<p>Set persistence from the Unity inspector or code.</p>
<div class="fragment"><div class="line">{c#}</div><div class="line">myAsset.Persistence = true;</div></div><!-- fragment --> <ul>
<li>Allows complete decoupling of components and groups of components, data from logic and logic from the rest of the Unity framework. It provides for a modular system that is more stable, easier to maintain and infinitely more testable.</li>
<li>Using custom assets as data containers allow for all vital information to be editable in the Unity inspector, both for game creation and Editor run-mode testing.</li>
<li>Problems can be isolated to integrity tests against one or more manager custom assets without having to run up a complete system.</li>
<li>All custom assets provide an implementation of the observer pattern. Changes can trigger logic in managers which can trickle up to visual changes at the Unity level.</li>
<li>Custom assets can be made to persist so that changes made in one session reload in the next session. The next release extends persistence to cloud storage.</li>
<li>Connectors are game object components that allow you to drive other components directly from custom asset data. Currently, there are connectors for a GameObject instance directly, Animator, Transform and RectTransform components.</li>
<li>Drivers are game object components that, given a data custom asset can call a public setter on other components on the game object. Many game objects provide public setters while others need a connector to be accessible.</li>
</ul>
<p>A custom asset is like any other Unity asset. Create a field for it in a MonoBehaviour or other <a class="el" href="namespace_custom_asset.html">CustomAsset</a> class and drop in the reference.</p>
<div class="fragment"><div class="line">{c#}</div><div class="line">public sealed class CustomAssetsExample: MonoBehaviour {</div><div class="line">  [SerializeField] private Float             maxFloat;</div><div class="line">  [SerializeField] private Float             currentFloat;</div><div class="line">  // ...</div><div class="line">}</div></div><!-- fragment --> <div class="image">
<img src="SampleCustomAsset.png" alt="sample custom asset for float"/>
</div>
<p>Custom assets aid decoupling. Many components can operate without directly knowing each other.</p>
<p>Access custom asset values by either casting or using the <code>Value</code> getter. ToString() will aways call ToString() on the Value field. </p><div class="fragment"><div class="line">{c#}</div><div class="line">Debug.LogFormat(&quot;{0} == {1}&quot;,maxFloat.Value, ((float) maxFloat);</div><div class="line">Debug.LogFormat(&quot;{0} == {1}&quot;,maxFloat.Value.ToString(), maxFloat.ToString());</div></div><!-- fragment --><h3>Instance</h3>
<p>There is a second way. As long as a custom asset is referenced as above at least once, it is available with code access elsewhere.</p>
<div class="fragment"><div class="line">{c#}</div><div class="line">Float lifetime = Float.Instance(&quot;Lifetime&quot;);</div><div class="line">UniqueAsset = UniqueAsset.Instance(); // &quot;UniqueAsset&quot; name optional</div></div><!-- fragment --><p>The static Instance method is also useful for in-memory custom "assets". The first call creates a copy while other calls retrieve a reference. You can even keep the value between invocations of the game by setting persistence.</p>
<div class="fragment"><div class="line">{c#}</div><div class="line">lifetime.Persistence = true;</div></div><!-- fragment --><p>Custom Assets are ScriptableObjects serialised and written to disk as an asset in the project.</p>
<div class="fragment"><div class="line">%YAML 1.1</div><div class="line">%TAG !u! tag:unity3d.com,2011:</div><div class="line">--- !u!114 &amp; 11400000</div><div class="line">MonoBehaviour:</div><div class="line">  m_ObjectHideFlags: 32</div><div class="line">  m_PrefabParentObject: {fileID: 0}</div><div class="line">  m_PrefabInternal: {fileID: 0}</div><div class="line">  m_GameObject: {fileID: 0}</div><div class="line">  m_Enabled: 1</div><div class="line">  m_EditorHideFlags: 0</div><div class="line">  m_Script: {fileID: 11500000, guid: 22f206729bb7e417e9b12649707e941e, type: 3}</div><div class="line">  m_Name: SampleFloatVariable</div><div class="line">  m_EditorClassIdentifier: </div><div class="line">  Description: </div><div class="line">  value: 0</div><div class="line">  readWrite: 1</div><div class="line">  persistent: 0</div></div><!-- fragment --><p> Each custom asset type has an entry on the <em><b>Create / CustomAssets / asset name</b></em>. Use it, select the resulting file and fill in the fields. If you want to load it from disk using <code>Resources.Load(pathFromResources)</code> you will need to place it in a <em><b>Resources</b></em> folder.</p>
<h3>OfType{T}</h3>
<p><code>CustomAsset.OfType&lt;T&gt;</code> is the base type for all custom assets except <code>Trigger</code>. Functionality includes being able to register events on change, persistence and some read-only protection. </p><div class="fragment"><div class="line">{c#}</div><div class="line">[CreateAssetMenu(menuName = &quot;Examples/LargerAssetSample&quot;)]</div><div class="line">public class LargerAssetSample : CustomAsset.OfType&lt;LargerAssetContents&gt; { }</div><div class="line"></div><div class="line">[Serializable]</div><div class="line">  public class LargerAssetContents {</div><div class="line">    public int    Order;</div><div class="line">    public float  Limit;</div><div class="line">    public string Name;</div><div class="line">  }</div></div><!-- fragment --><p>All <a class="el" href="namespace_custom_asset.html">CustomAsset</a> instances have a description field. Since you can use generic assets, it is useful to give others comments on what specific assets represent.</p>
<p>### Primitive Custom Assets </p><div class="fragment"><div class="line">{c#}</div><div class="line">  [SerializeField] private Float             currentFloat;</div><div class="line">  [SerializeField] private Integer           integer;</div><div class="line">  [SerializeField] private String            str;</div><div class="line">  [SerializeField] private Boolean           boolean;</div></div><!-- fragment --><p> Each if these custom assets can be in a project with or without supporting code. It is possible, for example, to have a <code>Float</code> value set in the <em><b>On Value Changed</b></em> field of a Slider or Scrollbar, then displayed using a driver like <code>CustomAsset.FloatDriver</code> to set the fill amount on a health bar Image component.</p>
<h4>Float</h4>
<p>The mutable <code>Float</code> custom asset also includes a range set in the inspector. Attempts to change the value outside the limits leave the value at the closest bound. It allows managers to increase or decrease a value without being concerned with going outside acceptable limits.</p>
<div class="fragment"><div class="line">health += 0.2f;</div><div class="line">// is clearer to read than</div><div class="line">if (health &lt; 0.8) health += 0.2f;</div></div><!-- fragment --><p>Set bounds with sliders or text entry. The latter is necessary if you need a value outside the range the sliders are set.</p>
<p>Conditions may require a range change. A tired warrior may not be able to have health over 80%. Use <code>Float.Minimum</code> and <code>Float.Maximum</code> to make the adjustments.</p>
<h3>Object (non-primitive) Custom Assets</h3>
<p>A class will better represent a more complex custom asset. There are a few boundaries. The class must be serialisable and any members you want to change in the inspector labelled as serialised fields.</p>
<div class="fragment"><div class="line">[Serializable] public class LargerAssetContents {</div><div class="line">  public int I;</div><div class="line">  public float F;</div><div class="line">  public string S;</div><div class="line">}</div></div><!-- fragment --><p>Take care while setting fields. The static <code>CustomAsset.Mutable.Field</code> class provides helpers for float, double, int, long, bool, string, Vector2, Vector3, Vector4 and Quaternion types. There is also a generic form for adding new structs. You need to provide a comparator.</p>
<div class="fragment"><div class="line">Field.Set(largeAssetContents, ref largeAssetContents.F, 12);</div><div class="line"></div><div class="line">    public static void Set(this WithEmitter asset, ref Vector4 field, Vector4 from) =&gt;</div><div class="line">      asset.Set(ref field, from, (a, b) =&gt; a == b);</div></div><!-- fragment --><h3>Enumeration</h3>
<p>Rather than use the c# language element <code>enum</code>, consider using an <code>Enumeration</code> custom asset. Using the Decoupler service environment as an example, we create it by sub-classing <code>Enumeration</code>.</p>
<div class="fragment"><div class="line">[CreateAssetMenu(menuName = &quot;Decoupler/Environment&quot;)]</div><div class="line">public class Environment : Enumeration { }</div></div><!-- fragment --><p>Now, use the menu to create as many environment elements as you need.</p>
<div class="image">
<img src="Environments.png" alt="Environments"/>
</div>
<p>Create a serialisable field <a class="el" href="namespace_custom_asset.html">CustomAsset</a> or MonoBehaviour that intends to use the enumeration.</p>
<div class="fragment"><div class="line">[Serializable] public class Context : Base {</div><div class="line">  [SerializeField] private Environment environment = default;</div><div class="line"></div><div class="line">  protected virtual bool Equals(Context other) =&gt;</div><div class="line">    base.Equals(other) &amp;&amp; Equals(environment, other.environment);</div><div class="line"></div><div class="line">  public override int GetHashCode() {</div><div class="line">    unchecked { return (base.GetHashCode() * 397) ^ (environment != null ? environment.GetHashCode() : 0); }</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>In this example, different services sub-class context and add additional fields. A common one is <code>platform</code>, allowing different service implementations for iOS, Android, Steam, and others.</p>
<p>During initialisation, the service manager decides which service are from the given current context.</p>
<div class="fragment"><div class="line">var useful = services.Where(service =&gt; service.context.Equals(context) &amp;&amp; service.IsExternalServiceAvailable());</div></div><!-- fragment --><h3>Trigger</h3>
<p>A trigger is unusual in that it does not have any data apart from <a class="el" href="namespace_custom_asset.html">CustomAsset</a> requirements. Triggers do not have persistence, so a subclass containing data cannot be saved.</p>
<h3>Members</h3>
<p>A custom asset with any content data also can store and retrieve separate copies by name. For persistent custom assets, the member names and values saved to storage along with the main value.</p>
<div class="fragment"><div class="line">{c#}</div><div class="line">[SerializeField] CustomAsset.Integer myInt;</div><div class="line">// ...</div><div class="line">myInt.Value = 22;</div><div class="line">myInt[&quot;One&quot;] = 1;</div><div class="line">myInt[&quot;Two&quot;] = 2;</div><div class="line"></div><div class="line">string[] names = myInt.MemberNames;</div><div class="line">Assert.AreEqual(names.Length, 2);</div><div class="line"></div><div class="line">Assert.AreEqual(myInt[&quot;One&quot;], 1);</div><div class="line">Assert.AreEqual(myInt.ToStringForMember(&quot;One&quot;), &quot;1&quot;);</div><div class="line">Assert.True(myInt.Contains(&quot;One&quot;));</div><div class="line"></div><div class="line">myInt.Remove(&quot;One&quot;);</div><div class="line">Assert.False(myInt.Contains(&quot;One&quot;));</div><div class="line"></div><div class="line">Assert.True(myInt.Contains(&quot;Two&quot;));</div><div class="line">myInt.Clear();</div><div class="line">Assert.False(myInt.Contains(&quot;Two&quot;));</div></div><!-- fragment --><p> <code>ToStringForMember</code> requires special mention as it can be use in Inspector event receivers to set values directly.</p>
<h3>AudioClips</h3>
<p>Playing one from a selection of audio clips have been a well-used proof of concept for <code>ScriptableObject</code>. Because custom assets, sets and some other toys from this package make the implementation even simpler, I am displaying the source here.</p>
<div class="fragment"><div class="line">{c#}</div><div class="line">  [CreateAssetMenu(menuName = &quot;Custom Assets/Sound Clips&quot;, fileName = &quot;Clips&quot;)]</div><div class="line">  public sealed class AudioClips : Set&lt;AudioClip&gt; {</div><div class="line">    [SerializeField, Header(&quot;Audio&quot;)]     private Range volume   = new Range(1, 1);</div><div class="line">    [SerializeField, RangeBounds(0, 2)]   private Range pitch    = new Range(1, 2);</div><div class="line">    [SerializeField, RangeBounds(0, 999)] private Range distance = new Range(1, 999);</div><div class="line"></div><div class="line">    public void Play(AudioSource source) {</div><div class="line">      source.clip        = Pick();</div><div class="line">      source.pitch       = pitch.Pick();</div><div class="line">      source.volume      = volume.Pick();</div><div class="line">      source.minDistance = distance.Min;</div><div class="line">      source.maxDistance = distance.Max;</div><div class="line">      source.Play();</div><div class="line">    }</div><div class="line">  }</div></div><!-- fragment --><p> <code>Range</code> class and <code>RangeBound</code> attribute are available in the custom assets package. <code>AudioClips</code> will work without them, but sliders are easier to use.</p>
<p>The actor, <code>Play</code>, requires an <code>AudioSource</code>. An audio source must be attached to the game object that is to make a sound so that it comes from the correct source. It cannot be part of a custom asset which is not a component.</p>
<p>Fortunately, the Unity framework has a solution to that problem. It is called <code>UnityEvent</code>.</p>
<div class="fragment"><div class="line">{c#}</div><div class="line">  [SerializeField] private AudioClips audioClips;</div><div class="line">  [SerializeField] private UnityEvent audioClipsEvent;</div></div><!-- fragment --><p> will display in the inspector as follows.</p>
<div class="image">
<img src="AudioClips1.png" alt="Audio Clips CustomAsset"/>
</div>
<div class="image">
<img src="AudioClips2.png" alt="Choose audio clip from a list"/>
</div>
<p>The reference to <code>AudioClips</code> is optional. It is only there so that we can change the fields in the editor without going to the asset.</p>
<p>If you are calling <code>Play</code> from code, then you can supply an <code>AudioSource</code> or a game object that has an audio source component.</p>
<div class="fragment"><div class="line">{c#}</div><div class="line">  [SerializeField] private AudioClips audioClips;</div><div class="line">  void Play() { audioClips.Play(gameObject); }</div><div class="line">  void Play1() { audioClips.Play(GetComponent&lt;AudioSource&gt;(); }</div></div><!-- fragment --><p>Using <code>AudioClips</code> wherever you have sound effects makes your game sound a lot more lively. You could also consider making similar assets for visual effects or animations.</p>
<h3>ChangeOverTime</h3>
<p>It is always fun to factor out common manager custom assets into common code. Health, mana, stamina and similar look better if changes are not instantaneous. Moreover, some, like poison, have to happen over a period. Create managers without code using the <code>ChangeOverTime</code> custom asset.</p>
<div class="image">
<img src="Health-SmallPotion.png" alt="Change custom asset over time"/>
</div>
 <div class="image">
<img src="Health-PoisonArrow.png" alt="Change custom asset over time"/>
</div>
<h3>Custom Asset Sets</h3>
<p><code>Set</code>, like <code>OfType</code> is a generic class. To instantiate it requires the type of set entries.</p>
<div class="fragment"><div class="line">{c#}</div><div class="line">[CreateAssetMenu(menuName = &quot;Examples/SetPicker&quot;, fileName = &quot;SetPickerSample&quot;)]</div><div class="line">public sealed class SetPickerSample : Set&lt;AudioClip&gt; {</div><div class="line">  public void Play() { AudioSource.PlayClipAtPoint(clip: Pick(), position: Vector3.zero); }</div><div class="line">}</div></div><!-- fragment --><p> This example can be used to play one of a selection of sounds. This is a great way to make a game sound less tedious.</p>
<h4>Pick()</h4>
<p>All classes inheriting from <code>Set</code> have a <code>Pick()</code> method with two controlling field entries:</p><ul>
<li><em><b>cycle</b></em>: True to return entries sequentially, false to get a random selection.</li>
<li><em><b>exhaustiveBelow</b></em>: If the number of entries in the set is below this value, then while <code>Pick()</code> returns a random entry, no entry is retrieved twice before all the others have had a turn. From a list of three, nothing appears random.</li>
</ul>
<p>These options are available in the editor when you create a custom asset from a <code>Set</code>.</p>
<h4>Add(entry)</h4>
<p>While in most cases the <code>Set</code> will be filled by the Unity Editor to save as an Asset, there are occasions where adding additional elements will be needed. </p><h4>Remove(entry)</h4>
<p>On occasions, a <code>Set</code> entry will expire, and it will be necessary to remove them. </p><h4>Contains(entry)</h4>
<p>See if a <code>Set</code> contains a specific entry. </p><h4>Count</h4>
<p>Retrieve the number of entries in a set. </p><h4>ForEach</h4>
<p>Call an action for every entry in a set. If the action returns false, all is complete. </p><div class="fragment"><div class="line">{c#}</div><div class="line">mySet.ForEach((s) =&gt; {return s!=&quot;Exit&quot;;});</div></div><!-- fragment --> <h4>StringSet</h4>
<p>Strings as a set have many usages. <code>Quotes</code> is an implementation of <code>StringSet</code>.</p>
<p>Serialised fields can be edited in the Unity Inspector just as you would a MonoBehaviour attached to a game object. Unlike a scriptable object, custom assets unload when play mode completes. In this way, they behave more like MonoBehaviours. There is a reason for this madness. In the Unity editor, scriptable objects remain loaded and only reload if the backing code or asset changes on disk. If we don't reset on leaving play mode, changed data from one run lives to the next.</p>
<p>If you can accept the tighter coupling, you can load custom assets my name. It is an alternative to dropping them into referring fields in the Unity inspector. The custom asset must reside in a directory under a <em><b>Resources</b></em> path - anywhere in the project.</p>
<div class="fragment"><div class="line">{c#}</div><div class="line">// expects /anywhere-in-assets/Resources/Audio/cow-sounds.asset</div><div class="line">var moos = Resources.Load&lt;AudioClips&gt;(&quot;Audio/cow-sounds&quot;);</div></div><!-- fragment --><p>The first significant departure from ScriptableObject that <a class="el" href="namespace_custom_asset.html">CustomAsset</a> provides is the ability to act as an event source.</p>
<p>Primitive custom assets (trigger, boolean, integer, float and string) are extremely easy to use. Drag a reference using the Unity editor into any MonoBehaviour or CustomEvent that needs to access or update them.</p>
<p>Drivers and Connectors (described below) also need a reference. They register for changing events. The event fires when and only when the custom asset changes.</p>
<h3>Polling</h3>
<p>No matter how hard we try there is data that changes, and we cannot be informed promptly. The technique of last resort is called polling - where we check periodically for change. The inspector for any mutable custom asset includes some polling fields. Just enable polling in the inspector and set the intervals.</p>
<div class="image">
<img src="Polling.png" alt="Polling for changes"/>
</div>
<p>Life begins now. Without writing any code, you can use the prepackaged custom assets and listeners to connect components without them knowing about each other.</p>
<p>Don't believe me? Create a game object inside a canvas and add a slider component.</p>
<p><em><b>Step 1</b></em>: Create a Float custom asset from the Unity editor main or context menu.</p>
<div class="image">
<img src="Slider-6-Create-Custom-Asset.png" alt="Menu to create a custom asset"/>
</div>
<p><em><b>Step 2</b></em>: Select the custom asset and add any initial data.</p>
<div class="image">
<img src="Float-CustomAsset-Editing.png" alt="Inspector view of CustomAsset.Float"/>
</div>
<p><em><b>Step 3</b></em>: Create a new GameObject in the Unity Hierarchy window. Make sure it is inside a Canvas GameObject.</p>
<div class="image">
<img src="Slider-1-Hierarchy.png" alt="Creating a slider"/>
</div>
<p><em><b>Step 4</b></em>: Go to the inspector for the game object <em>Slider</em> and add a slider component.</p>
<div class="image">
<img src="Slider-3-Component1.png" alt="UI Slider Component Inspector View"/>
</div>
<p><em><b>Step 5</b></em>: Add an <em>On Value Change</em> field and drag the Float custom asset into the associated field. Use the function drop-down to select <em><b>Float: Value</b></em>.</p>
<div class="image">
<img src="Slider-4-Component2.png" alt="Setting a slider to update a custom asset"/>
</div>
<p><em><b>Step 6</b></em>: Lock the inspector on the Float custom asset and run the scene. Drag the slider and watch the value change in the inspector.</p>
<div class="image">
<img src="Slider-2-Screen.png" alt="How the slider looks on the unity application window"/>
</div>
<p>For extra points, we can create a code-less health display bar.</p>
<p><em><b>Step 7</b></em>: Create a UI Button GameObject in a Canvas and change the image type to <em>Filled</em>. Note that moving the <em>Fill Amount</em> slider causes the button to change background proportionately.</p>
<div class="image">
<img src="Slider-7-Image-to-Fill.png" alt="Setting up an image to be filled driven by a Float custom asset"/>
</div>
<p><em><b>Step 8</b></em>: Press the <em>Add Component</em> Button then search for and add the <em>FloatDriver</em> component. Set the custom asset to the one created above and the component value setter to <em>Image.FillAmount</em>.</p>
<div class="image">
<img src="Slider-8-Listener.png" alt="Adding a CustomAsset.Float driver"/>
</div>
<p><em><b>Step 9</b></em>: Run the application and move the slider created above. The button fills and empties accordingly.</p>
<div class="image">
<img src="Slider-9-Image-Filling.png" alt="How the fill looks for this sample at 0.75"/>
</div>
<p>For components, like Animator, with named values Used <em>NamedFloatDriver</em> and it's siblings.</p>
<h3>Referencing <a class="el" href="namespace_custom_asset.html">CustomAsset</a> Contents</h3>
<p>Anywhere you want direct access to a custom asset, create a reference in your MonoBehaviour, <a class="el" href="namespace_custom_asset.html">CustomAsset</a> or ScriptableObject and assign it in the inspector.</p>
<div class="fragment"><div class="line">class MyHealthComponent : MonoBehaviour {</div><div class="line">  [SerializedField] CustomAsset.Float health;</div><div class="line"></div><div class="line">  private void OnEnable() =&gt; health.Value = 1.0F;</div><div class="line">}</div></div><!-- fragment --><p>You can also use the custom access emitter directly to react to change.</p>
<div class="fragment"><div class="line">private void HealthChanged() {</div><div class="line">  UpdateHealthBar(health.Value);</div><div class="line">  if (health.Value &lt;= 0) {</div><div class="line">    Fibers.Start.Do(DieAnimation).WaitFor(seconds: 5).Do(ReturnToStartScreen);</div><div class="line">  }</div><div class="line">}</div><div class="line">private void Start() =&gt; health.Emitter.Subscribe(HealthChanged);</div></div><!-- fragment --><h3>Code-Free <a class="el" href="namespace_custom_asset.html">CustomAsset</a> Usage</h3>
<p>Even the minimalistic code above is unnecessary for many <a class="el" href="namespace_custom_asset.html">CustomAsset</a> applications with the use of drivers and connectors.</p>
<h4>Drivers</h4>
<p>A driver is a MonoBehaviour that is designed to listen for custom asset changes and interact with other components of a game object directly. If you are passing information, the method must be in the <em><b>Dynamic Data</b></em> section.</p>
<p>Add them to the Inspector view by dragging them in or using the menu <em><b>Component/CustomAssets/Name of Driver</b></em>.</p>
<div class="image">
<img src="Image-FillAmount-Driver.png" alt="Sample CustomAsset.FloatDriver"/>
</div>
<p>Triggers are the exception and can use methods from <em><b>Static Parameters</b></em>.</p>
<div class="image">
<img src="Audio-Play-Driver.png" alt="Sample CustomAsset.TriggerDriver"/>
</div>
<p>All primitive data drivers have a matching version that starts with Named. These are to drive components like <em><b>Animator</b></em> that require a parameter name as well as the value. Since <em><b>Animator</b></em> does not expose it's internals to the Inspector, we need to resort to a connector.</p>
<div class="image">
<img src="Animator-Driver.png" alt="Sample CustomAsset.NamedFloatDriver"/>
</div>
<p>This package provides drivers for all primitive data type, but it is trivial to add new ones. </p><div class="fragment"><div class="line">public class MyBangDriver : ListenerComponent {</div><div class="line">  public Float Asset =&gt; Listener.AssetToMonitor as Float;</div><div class="line"></div><div class="line">  [Serializable] private class BangUnityEvent : UnityEvent&lt;Bang&gt; { }</div><div class="line"></div><div class="line">  [SerializeField] private BangUnityEvent componentValueToSet = default;</div><div class="line"></div><div class="line">  protected override void OnChange() =&gt;</div><div class="line">    componentValueToSet.Invoke(Asset.Value);</div><div class="line"></div><div class="line">  #if UNITY_EDITOR</div><div class="line">  [MenuItem(&quot;Component/CustomAssets/Bang Driver&quot;)]</div><div class="line">  private static void AddConnector() =&gt; Selection.activeTransform.gameObject.AddComponent&lt;MyBangDriver&gt;();</div><div class="line">  #endif</div><div class="line">}</div></div><!-- fragment --><p> Of course, you are unlikely to find a Unity component that knows what to do with a <em><b>Bang</b></em> object. You would be writing your own or relying on a Connect component (as described below) to distribute a <em><b>Bang</b></em> to the rest of the game object.</p>
<h4>Connectors</h4>
<p>If a component does not expose the data in the Unity inspector, then it is necessary to use a connector. The animator connector used above provides an excellent example.</p>
<p>Add them to the Inspector view by dragging them in or using the menu <em><b>Component/CustomAssets/Name of Connector</b></em>.</p>
<div class="fragment"><div class="line">public class AnimatorCustomAssetConnector : MonoBehaviour {</div><div class="line">  public void SetTrigger(string parameterName) =&gt; animator.SetTrigger(parameterName);</div><div class="line">  public void SetInteger(string parameterName, int value) =&gt; animator.SetInteger(parameterName, value);</div><div class="line">  public void SetFloat(string parameterName, float value) =&gt; animator.SetFloat(parameterName, value);</div><div class="line">  public void SetBoolean(string parameterName, bool value) =&gt; animator.SetBool(parameterName, value);</div><div class="line"></div><div class="line">  private Animator animator;</div><div class="line"></div><div class="line">  private void Awake() =&gt; animator = GetComponent&lt;Animator&gt;();</div><div class="line"></div><div class="line">  #if UNITY_EDITOR</div><div class="line">  [MenuItem(&quot;Component/CustomAssets/Animator Connector&quot;)]</div><div class="line">  private static void AddConnector() =&gt; Selection.activeTransform.gameObject.AddComponent&lt;AnimatorCustomAssetConnector&gt;();</div><div class="line">  #endif</div></div><!-- fragment --><p>Most connectors only require the information without a parameter name.</p>
<div class="fragment"><div class="line">public class TransformCustomAssetConnector : MonoBehaviour {</div><div class="line">  public void ScaleX(float value) =&gt;</div><div class="line">    transform.localScale = new Vector3(value, transform.localScale.y, transform.localScale.z);</div><div class="line">  // ...</div><div class="line">}</div></div><!-- fragment --><h3>Concrete Component Connectors</h3>
<p>The components listed here are part of a growing list of listeners that can be used to minimise coupling and reduce project specific code.</p>
<h4>Animator Connector</h4>
<p>An animator component relies on an outside source to set a named trigger, integer, float or bool variable. <em><b>AnimatorCustomAssetConnector</b></em> exposes all if them. When hooked up to a custom asset you can change the value where the logic is appropriate and the matching animation plays.</p>
<h4>RectTransform Connector</h4>
<p><em><b>RectTransformCustomAssetConnector</b></em> inherits from <em><b>TransformCustomAssetConnector</b></em> and adds the concepts of anchors, width, height, left, right, top, bottom as is appropriate for UI transforms.</p>
<h4>TransformConnector</h4>
<p>This connector allows for changes to the scale, rotation and position for any gameObject.transform. There is a video linked at the start of this document that uses changes of scale to show/hide a health-bar.</p>
<h4>GameObjectConnector</h4>
<p>The <code>GameObjectConnector</code> is a bit different. Add it to an existing GameObject with the menu ***Component/Custom Assets/GameObject Connector**** then drop in a custom asset that inherits from CustomAssets.Mutable.GameObject. Now code anywhere can access the game object.</p>
<p>If a custom asset is marked persistent in the Inspector, then it writes itself out to the PlayerPref database using a key combining the name and class.</p>
<p>Persistence occurs when the asset's <code>OnDisable</code> method is called - typically when the operating system has decided to throw the game out of memory.</p>
<p>For primitive assets, any updates happen without further coding.</p>
<div class="fragment"><div class="line">{c#}</div><div class="line">  Float age;</div><div class="line">  age.Value = 32.2f;</div></div><!-- fragment --><p>For custom assets containing a more complicated class or struct, the creator is responsible for marking changes either directly with <code>Changed()</code> or as part of the update. For the latter, creating accessors in the custom asset provided for clearer calling code that using Value directly - while calling <code>Set</code> on the update informs all listeners.</p>
<div class="fragment"><div class="line">{c#}</div><div class="line">[CreateAssetMenu(menuName = &quot;Examples/LargerAssetSample&quot;)]</div><div class="line">public class LargerAssetSample : CustomAsset.OfType&lt;CustomAssetsExample.LargerAssetContents&gt; {</div><div class="line">  public int AnInteger { get { return Value.I; } set { Set(() =&gt; Value.I = value); } }</div><div class="line"></div><div class="line">  public float AFloat { get { return Value.F; } set { Set(() =&gt; Value.F = value); } }</div><div class="line"></div><div class="line">  public string AString { get { return Value.S; } set { Set(() =&gt; Value.S = value); } }</div><div class="line">}</div></div><!-- fragment --><h3>Quotes</h3>
<p><code>Quotes</code> is a <code>StringSet</code> Custom Asset that if given a list of lines and a <code>TextAsset</code> returns a line using the <code>Pick</code> interface. A quote is formatted as a <em><b>body of the quote (attribution)</b></em> where the attribution is optional. The attribution is surrounded in brackets and must be at the end of the line. RTF is acceptable in the quote.</p>
<p>I would recommend setting <em><b>Exhaustive Below</b></em> to a figure like 50 or 100. Otherwise shorter lists appear to repeat entries too often.</p>
<h4>RTF</h4>
<p>RTF is a static function to convert a string quote into RTF format so that the attribution can be in grey. The text between brackets at the end of the line makes up the attribution.</p>
<div class="fragment"><div class="line">{c#}</div><div class="line">Debug.Log(Quotes.RTF(&quot;Life wasn&#39;t meant to be easy (George Bernard Shaw)&quot;));</div></div><!-- fragment --><p> produces <em><b>"***Life wasn't meant to be easy&lt;/strong&gt;&lt;/em&gt;"*** <em>George Bernard Shaw</em></b></em></p>
<p><em><b></b></em></p>
<p><em><b></p><h3>Health Bar</h3>
<p></b></em></p>
<p><em><b></p><ul>
<li>First, create a test scene (menu Assets/Create/Scene)</li>
<li>Create a <a class="el" href="namespace_custom_asset.html">CustomAsset</a> to store the health (menu Assets/Create/Custom Assets/Mutable/Float)</li>
</ul>
<p></b></em></p>
<p><em><b></p><div class="image">
<img src="Health-CustomAsset.png" alt="Float custom asset to represent player health"/>
</div>
<p></b></em></p>
<p><em><b></p><ul>
<li>Create a canvas (menu GameObject/UI/Canvas)</li>
<li>Create an empty child GameObject and call it <em><b>HealthBar</b></em><ul>
<li>Set it to a reasonable size</li>
</ul>
</li>
</ul>
<p></b></em></p>
<p><em><b></p><div class="image">
<img src="HealthBar.png" alt="Inspector view of HealthBar game object transform"/>
</div>
<p></b></em></p>
<p><em><b></p><ul>
<li>Create an image child (menu GameObject/UI/Image) and call it <em><b>Background</b></em><ul>
<li>Set colour to red</li>
<li>Set position and size to 0</li>
<li>Set X and Y anchors to Min 0, Max 1</li>
<li>Change X pivot to 0</li>
</ul>
</li>
</ul>
<p></b></em></p>
<p><em><b></p><div class="image">
<img src="Health-Background.png" alt="Inspector view of health-bar background"/>
</div>
<p></b></em></p>
<p><em><b></p><ul>
<li>Duplicate the Background, rename Foreground and change to green</li>
<li>The foreground is the only active component. We are going to reduce the scale so that the background shows through. Since transforms don't expose their data, we use a connector. (Drag connector into Inspector)</li>
<li>And we need a float driver to change the scale when our health custom asset changes (drag Float-Driver into the inspector)</li>
<li>This is where we hook them up (drop health asset into the driver and set the component to ScaleX)</li>
</ul>
<p></b></em></p>
<p><em><b></p><div class="image">
<img src="Health-Foreground.png" alt="Inspector view of health-bar foreground"/>
</div>
<p></b></em></p>
<p><em><b></p><ul>
<li>We created the health scene for two reasons - so that we can tweak our health bar before adding it to our project and so we can add manual and automatic testing. We need to add a component to drive the health bar. Fortunately, the Unity UI has a slider that works a treat. (Bounds//context//UI//Slider)</li>
</ul>
<p></b></em></p>
<p><em><b></p><div class="image">
<img src="Health-Slider.png" alt="Inspector view of health-bar test slider"/>
</div>
<p></b></em></p>
<p><em><b></p><ul>
<li>It is as simple as pie to hook in our custom asset (On Value Change/+/Health custom asset/Float.Value)</li>
<li>Run the scene and drag the slider to make the health bar change</li>
</ul>
<p></b></em></p>
<p><em><b></p><div class="image">
<img src="Health-Demo.png" alt="Running demo of health-bar"/>
</div>
<p></b></em></p>
<p><em><b></p><h3>Health Bar Integrity Testing</h3>
<p></b></em></p>
<p><em><b></b></em></p>
<p><em><b>The integrity test loads our sample scene and exercises the slider to make sure that the health bar behaved accordingly.</b></em></p>
<p><em><b></p><div class="fragment"><div class="line">public class HealthBarTranscript : PlayModeTests {</div><div class="line">  private static string scenePath = &quot;Health&quot;;</div><div class="line"></div><div class="line">  //- PlayModeTests provides a support function to make sure</div><div class="line">  //- the scene is in the Build Settings so it can be run</div><div class="line">  #if UNITY_EDITOR</div><div class="line">  [InitializeOnLoadMethod]</div><div class="line">  private static void AddSceneToBuildSettings() =&gt; AddSceneToBuildSettings(scenePath);</div><div class="line">  #endif</div><div class="line"></div><div class="line">  //- We will only need a single method to test the integrity</div><div class="line">  //- of the health-bar functionality.</div><div class="line">  [UnityTest] public IEnumerator HeathBarTests() {</div><div class="line">    yield return LoadScene(scenePath);</div><div class="line">    //- We will need a reference to the slider for control</div><div class="line">    //- and the foreground to check the results</div><div class="line">    var slider     = Component&lt;Slider&gt;(&quot;Testing Slider&quot;);</div><div class="line">    var foreground = Component&lt;RectTransform&gt;(&quot;Foreground&quot;);</div><div class="line">    //- Set the slider to match the health starting value</div><div class="line">    slider.value = foreground.localScale.x;</div><div class="line"></div><div class="line">    //- local function to set and check a health value.</div><div class="line">    //- Note the wait. It could be one frame, but I have made it longer</div><div class="line">    //- so we can see the test happening.</div><div class="line">    IEnumerator setAndCheck(float health) {</div><div class="line">      slider.value = health;</div><div class="line">      yield return new WaitForSeconds(0.1f);</div><div class="line">      var scale = foreground.localScale.x;</div><div class="line">      Assert.AreApproximatelyEqual(health, scale);</div><div class="line">    }</div><div class="line"></div><div class="line">    //- Check bounds</div><div class="line">    yield return setAndCheck(0);</div><div class="line">    yield return setAndCheck(1);</div><div class="line">    //- Ramp up and make sure all matches</div><div class="line">    for (float health = 0; health &lt;= 1; health += 0.05f) yield return setAndCheck(health);</div><div class="line">    //- Now let&#39;s do some random ones</div><div class="line">    //- in case change of direction can be a problem.</div><div class="line">    for (int i = 0; i &lt; 20; i++) {</div><div class="line">      yield return setAndCheck(Random.Range(0f, 1f));</div><div class="line">    }</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p></b></em></p>
<p><em><b></p><h3>Health Manager</h3>
<p></b></em></p>
<p><em><b> In this context, a manager is logic (code) with a single concern (a data item). If that concern is not directly visual or player interactive then it is best served with a custom asset. By limiting I/O to some extremely simple and stupid MonoBehaviours, we can test almost all of the game components in isolation or groups as needed.</b></em></p>
<p><em><b>To allow adequate testing of custom asset managers, they should not be coupled with each other or the Unity framework. We accomplish everything with custom assets and observers.</b></em></p>
<p><em><b>Following the single responsibility principle, each manager should be small and focused. In this case, the health manager manages the permanent improvements to health over time.</b></em></p>
<p><em><b></p><ul>
<li>A manager needs the code because it holds game logic</li>
</ul>
<p></b></em></p>
<p><em><b></p><div class="fragment"><div class="line">//- Custom assets must be created to physical files in the project.</div><div class="line">//- We could have more than one.</div><div class="line">[CreateAssetMenu(menuName = &quot;Managers/Health&quot;), Serializable]</div><div class="line">public class HealthManagerTranscript : Manager {</div><div class="line">  //- The field we are managing</div><div class="line">  [SerializeField] private Float health = default;</div><div class="line">  //- Health will slowly increase over time.</div><div class="line">  //- A permanent game ability could change this value</div><div class="line">  [SerializeField] private Float trickleChargePerSecond = default;</div><div class="line"></div><div class="line">  protected override void Initialise() {</div><div class="line">    base.Initialise();</div><div class="line">    //- We can just update health every second.</div><div class="line">    //- Float corrects for health over the maximum</div><div class="line">    void trickleCharge(Fiber fiber) =&gt;</div><div class="line">      health.Value += trickleChargePerSecond;</div><div class="line">    //- Fibers are efficient, only waking once a second to update health value</div><div class="line">    Fiber.Start.Begin.WaitFor(seconds: 1.0f).Do(trickleCharge).Again.Finish();</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p></b></em></p>
<p><em><b></p><ul>
<li>Create a new <em><b>Float</b></em> custom asset and call it <em><b>TrickleChargePerSecond</b></em>.</li>
</ul>
<p></b></em></p>
<p><em><b></p><div class="image">
<img src="Health-TrickleChargePerSecond.png"/>
</div>
<p></b></em></p>
<p><em><b></p><ul>
<li>Create a health manager with the menu or context menu <em><b>Assets // Create // Manager // Health</b></em>. Fill custom asset references with <em><b>Health</b></em> and <em><b>TrickleChargePerSecond</b></em> custom asset references.</li>
</ul>
<p></b></em></p>
<p><em><b></p><div class="image">
<img src="Health-Manager.png" alt="A health manager ready for deployment"/>
</div>
<p></b></em></p>
<p><em><b></p><ul>
<li>Decoupled Managers need to tell our game that they exist. Create a game object from the <em><b>GameObject/Create Managers</b></em> menu and drag a reference to your manager into it. It only needs to be done in your opening scene.</li>
</ul>
<p></b></em></p>
<p><em><b></p><div class="image">
<img src="Health-Managers-GameObject.png" alt="Inspector view of health manager"/>
</div>
<p></b></em></p>
<p><em><b></p><ul>
<li>All other health changes can be made using <code>CustomAsset.ChangeOverTime</code> instances.</li>
</ul>
<p></b></em></p>
<p><em><b></p><div class="image">
<img src="Health-SmallPotion.png" alt="Effects of small healing potion"/>
</div>
<p></b></em></p>
<p><em><b></p><div class="image">
<img src="Health-PoisonArrow.png" alt="Effects of being hit by a poison arrow"/>
</div>
<p></b></em></p>
<p><em><b></p><h4>Health Manager Integrity Testing</h4>
<p></b></em></p>
<p><em><b></b></em></p>
<p><em><b>Managers do not need a scene to run, but they do need one for Fibers. They use <code>UnityTest</code> but do nothing visual. We could take this further by making sure that the increase in health matches the trickle charge per second value.</b></em></p>
<p><em><b></p><div class="fragment"><div class="line">//- While Fibers do not need to run from a MonoBehaviour,</div><div class="line">//- they still need a running scene - so we use UnityTest</div><div class="line">public class HealthManagerTest : PlayModeTests {</div><div class="line">//- The Timeout attribute uses Time.timeScale.</div><div class="line">[UnityTest, Timeout(100000)] public IEnumerator HealthManager() {</div><div class="line">  //- Our health component will take 1,000 seconds</div><div class="line">  //- to go from zero to full. Let&#39;s speed things up by 10x</div><div class="line">  Time.timeScale = 10;</div><div class="line">  try {</div><div class="line">    //- We don&#39;t need a specific scene, just load the custom assets</div><div class="line">    Manager.Load&lt;HealthManagerTranscript&gt;(&quot;HealthManager.asset&quot;);</div><div class="line">    var health = Manager.Load&lt;Float&gt;(&quot;Health.asset&quot;);</div><div class="line">    //- Set to 0 since once a custom asset is loaded in the editor </div><div class="line">    //- it stays loaded</div><div class="line">    health.Set(0);</div><div class="line">    //- It looks like forever, but the Timeout attribute</div><div class="line">    //- will cause a test failure after 10 seconds</div><div class="line">    while (true) {</div><div class="line">      //- This causes a 1/10th of a second delay due to the modified scale</div><div class="line">      yield return new WaitForSeconds(1.0f);</div><div class="line">      //- Leaving once the test passes is a successful result.</div><div class="line">      //- This should take 1 second at the current time scale.</div><div class="line">      if (health &gt;= 0.01f) yield break;</div><div class="line">    }</div><div class="line">  } finally {</div><div class="line">    //- reset the time scale for other tests.</div><div class="line">    Time.timeScale = 1;</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p></b></em></p>
<p><em><b></p><h3>Refactoring to use Custom Assets</h3>
<p></b></em></p>
<p><em><b></b></em></p>
<p><em><b>Below is a typical game manager MonoBehaviour for a 2D game. Usually, I wouldn't refactor a working system. Whenever I need to fix a bug, add a feature or make a performance improvement, I refactor the relevant code.</b></em></p>
<p><em><b>For example, if I needed to update <code>KillPlayer</code> I would factor it out into a death manager and leave everything else as-is. If I were a good boy (and I am), I would write an integration test to go with it. The actual work would be minimal, and the stability gains for future changes makes it all worth-while.</b></em></p>
<p><em><b></p><h4>The Original Code</h4>
<p></b></em></p>
<p><em><b></b></em></p>
<p><em><b></p><div class="fragment"><div class="line">public sealed class GameManager : MonoBehaviour {</div><div class="line">  public static GameManager Instance { get; private set; }</div><div class="line"></div><div class="line">  public int Lives { get; private set; }</div><div class="line"></div><div class="line">  public event Action&lt;int&gt; OnLivesChanged;</div><div class="line">  public event Action&lt;int&gt; OnCoinsChanged;</div><div class="line"></div><div class="line">  private int coins;</div><div class="line">  private int currentLevelIndex;</div><div class="line"></div><div class="line">  private void Awake() {</div><div class="line">    if (Instance != null) {</div><div class="line">      Destroy(obj: gameObject);</div><div class="line">    } else {</div><div class="line">      Instance = this;</div><div class="line">      DontDestroyOnLoad(target: gameObject);</div><div class="line">      RestartGame();</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  public void KillPlayer() {</div><div class="line">    Lives--;</div><div class="line">    if (OnLivesChanged != null) OnLivesChanged(Lives);</div><div class="line"></div><div class="line">    if (Lives &lt;= 0) {</div><div class="line">      RestartGame();</div><div class="line">    } else {</div><div class="line">      SendPlayerToCheckpoint();</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  private void SendPlayerToCheckpoint() {</div><div class="line">    var checkpointManager = FindObjectOfType&lt;CheckpointManager&gt;();</div><div class="line">    var checkpoint        = checkpointManager.GetCheckpointThatWasLastPassed();</div><div class="line">    var player            = FindObjectOfType&lt;PlayerMovementController&gt;();</div><div class="line"></div><div class="line">    player.transform.position = checkpoint.transform.position;</div><div class="line">  }</div><div class="line"></div><div class="line">  public void MoveToNextLevel() {</div><div class="line">    currentLevelIndex += 1;</div><div class="line">    SceneManager.LoadScene(currentLevelIndex);</div><div class="line">  }</div><div class="line"></div><div class="line">  private void RestartGame() {</div><div class="line">    currentLevelIndex = 0;</div><div class="line">    Lives             = 3;</div><div class="line">    coins             = 0;</div><div class="line">    if (OnCoinsChanged != null) OnCoinsChanged(coins);</div><div class="line">    SceneManager.LoadScene(sceneBuildIndex: 0);</div><div class="line">  }</div><div class="line"></div><div class="line">  public void AddCoin() {</div><div class="line">    coins++;</div><div class="line">    if (OnCoinsChanged != null) OnCoinsChanged(coins);</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p></b></em></p>
<p><em><b></p><h4>Change Summary</h4>
<p></b></em></p>
<p><em><b></p><ul>
<li><code>Instance</code> and <code>Awake</code> are removed as not necessary since once we refactor all the code</li>
<li><code>Lives</code>, <code>coins</code> and <code>currentLevelIndex</code> becomes a <code>CustomAsset.Integer</code></li>
<li><code>OnLivesChanged</code> is provided by the custom asset <code>Lives</code> - no code required</li>
<li><code>OnCoinsChanged</code> is provided by the custom asset <code>Coins</code> - no code required</li>
<li><code>KillPlayer</code> is absorbed into the manager custom asset <code>PlayerDeathManager</code></li>
<li><code>SendPlayerToCheckpoint</code> is absorbed into the manager custom asset <code>PlayerDeathManager</code></li>
<li><code>MoveToNextLevel</code> becomes <code>scene.Value += 1</code></li>
<li><code>RestartGame</code> could become a <code>CustomAsset.Trigger</code> called <code>RestartManager</code></li>
<li><code>AddCoin</code> disappears and logic accesses the <code>Coins</code> custom asset directly.</li>
</ul>
<p></b></em></p>
<p><em><b></p><h4>PlayerDeathManager</h4>
<p></b></em></p>
<p><em><b></b></em></p>
<p><em><b></p><div class="fragment"><div class="line">[CreateAssetMenu(menuName = &quot;Managers/Player Death&quot;), Serializable]</div><div class="line">public class PlayerDeathManager : Manager {</div><div class="line">  [SerializeField] private Float      health       = default;</div><div class="line">  [SerializeField] private Integer    coins        = default;</div><div class="line">  [SerializeField] private Integer    lives        = default;</div><div class="line">  [SerializeField] private Integer    maximumLives = default;</div><div class="line">  [SerializeField] private Integer    scene        = default;</div><div class="line">  [SerializeField] private GameObject player       = default;</div><div class="line">  [SerializeField] private GameObject checkpoint   = default;</div><div class="line"></div><div class="line">  protected override void Initialise() =&gt; health.Emitter.Subscribe(OnHealthChange);</div><div class="line"></div><div class="line">  private void OnHealthChange() {</div><div class="line">    if (health &lt;= 0) KillPlayer();</div><div class="line">  }</div><div class="line"></div><div class="line">  private void KillPlayer() {</div><div class="line">    if (lives &lt;= 1) {</div><div class="line">      RestartGame();</div><div class="line">    } else {</div><div class="line">      SendPlayerToCheckpoint();</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  private void RestartGame() {</div><div class="line">    scene.Value = 0;</div><div class="line">    lives.Value = maximumLives;</div><div class="line">    coins.Value = 1;</div><div class="line">  }</div><div class="line"></div><div class="line">  private void SendPlayerToCheckpoint() =&gt; player.Value.transform.position = checkpoint.Value.transform.position;</div><div class="line">}</div></div><!-- fragment --><p></b></em></p>
<p><em><b></p><h4>SceneManager</h4>
<p></b></em></p>
<p><em><b></b></em></p>
<p><em><b></p><div class="fragment"><div class="line">[CreateAssetMenu(menuName = &quot;Managers/Scene&quot;), Serializable]</div><div class="line">public class SceneManager : Manager {</div><div class="line">  [SerializeField] private Integer scene = default;</div><div class="line"></div><div class="line">  protected override void Initialise() =&gt; scene.Emitter.Subscribe(OnSceneChange);</div><div class="line"></div><div class="line">  private void OnSceneChange() =&gt; UnityEngine.SceneManagement.SceneManager.LoadScene(sceneBuildIndex: scene);</div><div class="line">}</div></div><!-- fragment --><p> </b></em></p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
